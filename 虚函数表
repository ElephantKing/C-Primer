一下函数不能声明为虚函数

1.普通函数（不能被覆盖） 
2.友元函数（C++不支持友元函数继承）
3.内联函数（编译期间展开，虚函数是在运行期间绑定）
4.构造函数（没有对象不能使用构造函数，先有构造函数后有虚函数，虚函数是对对象的动作） 
5.静态成员函数（只有一份大家共享） 

所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。
模板技术，RTTI技术，虚函数技术
对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。
C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。


假设我们有这样的一个类：
 
class Base {
     public:
            virtual void f() { cout << "Base::f" << endl; }
            virtual void g() { cout << "Base::g" << endl; }
            virtual void h() { cout << "Base::h" << endl; }
 
};
 
按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：
 
          typedef void(*Fun)(void);
 
            Base b;
 
            Fun pFun = NULL;
 
            cout << "虚函数表地址：" << (int*)(&b) << endl;
            cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;
 
            // Invoke the first virtual function 
            pFun = (Fun)*((int*)*(int*)(&b));
            pFun();
运行结果：
            (Fun)*((int*)*(int*)(&b)+0);  // Base::f()
            (Fun)*((int*)*(int*)(&b)+1);  // Base::g()
            (Fun)*((int*)*(int*)(&b)+2);  // Base::h()

一般继承（无虚函数覆盖）
下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：
 


 
请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：
对于实例：Derive d; 的虚函数表如下：



 
我们可以看到下面几点：
1）虚函数按照其声明顺序放于表中。
2）父类的虚函数在子类的虚函数前面。
 
一般继承（有虚函数覆盖） 
覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。
 
 

 
为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：
 


 

我们从表中可以看到下面几点，
1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
2）没有被覆盖的函数依旧。
 
这样，我们就可以看到对于下面这样的程序，
 
            Base *b = new Derive();
 
            b->f();
 
由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。
多重继承（无虚函数覆盖） 
下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。
 

 
 
对于子类实例中的虚函数表，是下面这个样子：


 

我们可以看到：
1）  每个父类都有自己的虚表。
2）  子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）
 
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数
