1.为了兼容C，C++中所有字符串字面值都由编译器自动在末尾添加一个空字符，所以"a"包含2个字符，占2个字节。
2.直接初始化和复制初始化：这两者的差别对于内置类型来说没有差别，但对于类类型有一定区别，如下：
     1、ClassTest ct1("ab");这条语句属于直接初始化，它不需要调用复制构造函数，直接调用构造函数ClassTest(const char *pc)，所以当复制构造函数变为私有时，它还是能直接执行的。

2、ClassTest ct2 = "ab";这条语句为复制初始化，它首先调用构造函数ClassTest(const char *pc)函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2；所以当复制构造函数变为私有时，该语句不能编译通过。

3、ClassTest ct3 = ct1;这条语句为复制初始化，因为ct1本来已经存在，所以不需要调用相关的构造函数，而直接调用复制构造函数，把它值复制给对象ct3；所以当复制构造函数变为私有时，该语句不能编译通过。

4、ClassTest ct4（ct1）；这条语句为直接初始化，因为ct1本来已经存在，直接调用复制构造函数，生成对象ct3的副本对象ct4。所以当复制构造函数变为私有时，该语句不能编译通过。

注：第4个对象ct4与第3个对象ct3的创建所调用的函数是一样的，但是本人却认为，调用复制函数的原因却有所不同。因为直接初始化是根据参数来调用构造函数的，如ClassTest ct4（ct1），它是根据括号中的参数（一个本类的对象），来直接确定为调用复制构造函数ClassTest(const ClassTest& ct)，这跟函数重载时，会根据函数调用时的参数来调用相应的函数是一个道理；而对于ct3则不同，它的调用并不是像ct4时那样，是根据参数来确定要调用复制构造函数的，它只是因为初始化必然要调用复制构造函数而已。它理应要创建一个临时对象，但只是这个对象却已经存在，所以就省去了这一步，然后直接调用复制构造函数，因为复制初始化必然要调用复制构造函数，所以ct3的创建仍是复制初始化。

5、ClassTest ct5 = ClassTest();这条语句为复制初始化，首先调用默认构造函数产生一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct5。所以当复制构造函数变为私有时，该语句不能编译通过。

产生上面的运行结果的主要原因在于编译器的优化，而为什么把复制构造函数声明为私有（private）就能把这个假象去掉呢？主要是因为复制构造函数是可以由编译默认合成的，而且是公有的（public），编译器就是根据这个特性来对代码进行优化的。然而如里你自己定义这个复制构造函数，编译则不会自动生成，虽然编译不会自动生成，但是如果你自己定义的复制构造函数仍是公有的话，编译还是会为你做同样的优化。然而当它是私有成员时，编译器就会有很不同的举动，因为你明确地告诉了编译器，你明确地拒绝了对象之间的复制操作，所以它也就不会帮你做之前所做的优化，你的代码的本来面目就出来了。
举个例子来说，就像下面的语句：
ClassTest ct2 = "ab";
它本来是要这样来构造对象的：首先调用构造函数ClassTest(const char *pc)函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2。然而编译也发现，复制构造函数是公有的，即你明确地告诉了编译器，你允许对象之间的复制，而且此时它发现可以通过直接调用重载的构造函数ClassTest(const char *pc)来直接初始化对象，而达到相同的效果，所以就把这条语句优化为ClassTest ct2（"ab"）。
而如果把复制构造函数声明为私有的，则对象之前的复制不能进行，即不能把临时对像作为参数，调用复制构造函数，所以编译就认为ClassTest ct2 = "ab"与ClassTest ct2（"ab"）是不等价的，也就不会帮你做这个优化，所以编译出错了。
转自：http://blog.csdn.net/ljianhui/article/details/9245661
3.非const变量默认为extern，要使const变量能在其他文件中使用，必须显式指定其为extern，即：
//file_1.h
const int a = 100;
该变量在其他文件中即使用extern int a;进行声明，但也是不能访问。

如要访问需改成：extern const int a = 100;
而非const变量则不需要。
4.非const引用只能绑定到同类型的对象上，如下：
int a;
double b;
int &ra = a;//ok
int &rb = b;//error

然而const引用可以绑定到相关类型(初步理解为可隐式转化的类型)或字面值常量上,如下：
double b;
const int &rb = b;//ok，且此时当b变化时，rb并不改变，此句等价于int temp = (int)b; const int &rb = temp;即rb实际上和临时变量temp的绑定。
const int &rc = 123;//ok
5.在对迭代器进行解引用的时候，如果容器里面是对象，则应写成(*iter).member，因为*的优先级比.的低。指针也是。
6.const与指针：
int a = 10;
const int *pa = &a;//不能通过pa修改a的值，但是pa可以不指向a，改指向其他的int

int a = 10;
int *const pa = &a;//pa的值不能修改，即他不能指向别的int，但可以通过pa修改a的值

int a = 10;
const int *const pa = &a;//pa不能指向别的int，也不能通过pa修改a，但是可以通过a改变a的值，a = 1000;//OK

C++ Primer P111,指向const的指针理解为 自以为指向const的指针，即他只是用来约束自己，并不影响他人。
7.应该将不需要修改的引用形参定义为const引用，普通的非const引用形参在使用时不灵活，这样的形参只能接受同类型的非const实参，不能接受const对象，也不能接受字面值或者表达式，如下：
void print(int &a){cout<<a<<endl;}//该函数只能接受int类型的参数，如下都是错误调用
const int b = 10;
int c = 10;
print(b);//error
print(10);//error
print(c+1);//error
如果将函数修改为void print(const int &a){...}，上述调用都正确。
8.函数的默认实参的约束：可以在函数声明中指定默认参数，也可以在定义中指定，在一个文件中，只能为一个形参指定默认实参一次。下面的例子是错误的：
//ff.h
int ff(int i = 0);
//ff.c
#include "ff.h"
int ff(int i = 0){...}
9.const对象、指向const的指针或引用只能调用其const成员函数，如果尝试调用他们的非const成员函数，则是错误的。
10.函数的重载：不能仅通过函数的返回值不同而形成重载。形参与const形参的等价性仅适用于非引用形参。有const引用形参的函数则与有非const引用形参的函数是不同的，他们构成重载。类似的有指向const类型的指针形参与带有指向非const类型的指针形参的函数构成重载。
11.指向函数的指针：
有函数bool func(int i);
函数指针定义：bool (*p)(int);p即为指向带有一个int参数的函数，并有bool类型返回值的函数。给p赋值后就可以使用了：p = func;p(1);
还可以使用typedef定义一个新的类型：typedef bool (*p)(int);此时的p就不是一个指针了，而是一个类型，可以用他来定义指针：p p1 = func;这里的p1就相当于之前的p，而这里的p就是一个新的类型。给p1赋值的方式有如下几种：同类型的指针，同类型的函数(或引用)，0。切不存在不同类型的函数指针的转换。
12.容器元素快速删除：vector<Type>().swap(v);
   容器空间压缩：vector<Type>(v).swap(v);

P281待续。。。。
下面是面向对象C++:
1.有成员函数
void get() const{}和void get(){}
他们是构成重载的，用const对象调用时，调用前面一个函数。
且不能用const对象调用非const方法，且const方法不能调用非const方法。
2.在普通的非const成员函数中，this的类型是一个指向类类型的const指针，即可以改变this指向的值，但是不能改变指针的地址。在const成员函数中，this指向的值也不能改变。所以在const成员函数返回指向对象的普通引用是错误的，const成员函数只能返回*this作为一个const引用。
即：A& get() const{ return *this;//error}
应该为 const A& get() const{return *this;//OK}
3.const成员函数虽然不能改变类的成员，但是如果将类的成员对象声明前加上mutable，即mutable int o_a;就可以随便改变o_a的值。
4.成员函数的形参表和函数体在类的作用域范围中，但是返回值不在。即如果函数在类外定义，那么用于返回类型的名字在类作用域之外。如果返回值由类定义，则必须使用域限定符。
5.成员函数的初始化列表中的初始化顺序是根据成员的定义顺序而定，与初始化列表中的顺序无关。初始化类类型的时候，可以用一个类的对象给他赋值，也可以用构造函数给他赋值，如：void A():name(10,'a'){}，name是string类型的。
6.具有类类型的成员通过其默认的构造函数初始化，内置和复合类型的成员变量，如指针和数组，只对定义在全局作用域中的对象才初始化，对于定义在局部的对象，则不初始化。
7.
